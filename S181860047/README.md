+ task1
  + 类型设计
  + ![](http://www.plantuml.com/plantuml/png/ZLF1ajCm3BtxAtnqOBkVm2ozx8N33cNWm71m4ZKON3lZsBiifV-ELCLEchGpsulLf-Ud9ybv6A8ECHsiQAmU1la8y1V2KVJ1FEi84jFHD2Ciuq_WIFIfjeXVfZk8Np93LLaZo9qFT0nqbAlFthHoWCX9TS4fT-Kk1kEwxpzahyC0JrOxnP3iCIuyLeC_qAG8cO7YVIN4IGXmwI0VVGhjrDdUE6sbSL66ArXt1QiBzkG74urtiX-3vJoe58tZ76nVFsltMvrBOL1bSWPKjPn9rbUhGeLQCjr4NmgzwBwas99s7dSOvXP8uAks2HJF2Y48Uzs0_8ITrnQEuYssRlXP53ZnCoDfEAx6IMiUm-6Yapv5DRgHbiyxKZQbaPp5Mkfg1hMZ_nY2VfscnEy4SGumKGpk6Y27v9CgWbXz0UDbwpknJViz16Y_1HEHyt8-K6eQ9R_kev3ucpTclMx9Bxe32mTmSQXM9Fecr0HFncdKLhlPNBUfnbvpjJnVBg35ZSgwAipoRdY8TvAENvXVsxbb9NifMvryB5POtjM8gobVqqbj2Nwtz_V_FkJh8jCs6r-AY7ddJESuByvlDXcXtTBjioBC_ZALb_wUWA9E4AfE7fYQ8M32EwnHhZo0QzF1_WS0)
  
  
  
  
  
  
  
  + 时序图
  + ![](http://www.plantuml.com/plantuml/png/LP0zQyD038Pt_GgDzj10Fw0GQ4cxPEdMRY739LOSK_Lqw7IOzjVtEBc6Jdu_7lIQssKBQkMBuMsAX3VFsBvRdE9aQxQNeaCDKp5yN9m9SgrXJ_H3sYXNsv7iuqhku5tKl5wKdyRkjPnEJ1xsVkK_biamDxEsw--rwP8WYX4oNGnkMxGnUL4Dtmw6Ed0uieiCTtNP3aVK43zpnnH7kpxzjHltFTmleyWI1cSnn07FWRbLNGyFEEjaX8FCiN8ZogLL3SnpI9XKpfGpK0sY6C6kglhClm00)
  + 代码理解：刚开始看代码的时候感觉比自己想象的排队场景复杂的多了，自己能想到的也就是一个排序算法，可是就像老师说的谁不会几个排序算法了，所以排序在这次项目中变得无关轻重了。老师通过模拟现实，将需要排序的每一个对象抽象成了一条线上的7个位置，所以在class Line中有一个内嵌的对象数组positions，并且该类中成员方法有put和get方法，分别给对应位置放置一个对象和获取该位置的对象。还有一个获取整个Line的所有位置上的可排列的对象数组一起toString方法。其中Line的内嵌对象数组类型定义成了Line的内部类position，该position类的成员是一个接口Linable，以及一个set方法。所以最终Line的每个position实际上存储的就相当于是一个Linable对象了（顾名思义这条线上的每个对象是可排序的）。而Linable在实现的时候是一个接口，该接口只是规定了每个可排序对象必须实现getPosition(),setPosition(),getValue()方法，所以最后用Gourd类实现了Linable接口。Gourd类表示了最终要排序的葫芦娃，因为葫芦娃每个有自己的属性，用rgb表示，final表示该属性一经初始化后续不可修改。而且Gourd中有一个方法rank（）返回了每个葫芦娃的“位置”属性，表示了他在position中的顺序，后续的排序是以此为基础进行排序的（getValue()方法委托调用的getRank())。对于需要排序的Line是由爷爷操作的，所以代码中又有一个类Geezer作为爷爷的抽象，他有一个静态成员 theGeezer和静态方法getTheGeezer，可以直接调用不一类与对象。因为爷爷需要给葫芦娃排序，所以有一个私有成员是Sorter对象，可以用setSorter方法设定排序算法。在这些准备工作做好爷爷开始排序即：调用lineup方法这是爷爷最重要的一环，首先他要有一个参数（Line）line，存储了待排序的一列葫芦娃，一个局部变量log（String类型）用来继续排序的交换位置的过程，首先line.toArray(),得到一列葫芦娃对象的数组，然后初始化一个int[] ranks（长度和葫芦娃数量相同），里面按顺序保存每个葫芦娃的rank(value)，将这个ranks数组加载到sorter中，sorter对ranks排序。排序的时候实际上是对ranks排序，（因为葫芦娃是用enum实现的，它的rank刚好巧妙地设置为ordinal（）+1,就是从1，2，3这样排序的只是在Line put葫芦娃地时候是打乱排列的所以需要排序。）排序中的交换过程用String 记录下来。将每一次地交换过程存储到一个sortSteps数组中，然后 对于每一个step执行execue方法，这个方法执行的是对记录的具体的葫芦娃地交换操作的执行，在line中葫芦娃交换了之后，将当前列信息保存到log中 ，依次执行到结束。所以最后log保存了每一次交换后的葫芦娃信息，所以最后地命令行指令将log（result.txt）显示出来就可以看到了可视化的排序过程。
  + 至于改进的话感觉不到有什么很大的改进空间，要是结合task2来说可能有Gourd用enum实现是优点，也是缺点，优点是每个Gourd生来就有一个rank，无需自己设置，或者说自己设置的时候很方便。但是缺点是enum适合数量较少地情况，因为数量较多的话enum根本不能胜任。
  
+ task2
  + 类型设计
  + ![](http://www.plantuml.com/plantuml/png/pLNDRXCn4BxxANpSXMx50q1LSW6a81M2u80GSZREOkBOAzlRKWNUdPdrx6JZDbAFpSMpt_pCvyypodLCAgHXRqLhLOnovTHE7qGVpArAMe8tcJQZCltIeo7wOMq1FN5sEdqXVrLF-K6kVC0ZZiUKUElDHaQTihCwYU5SkKh1kExx3zch4FMDLQxAaEp1vhXSJV_HxP0qHM3nlXRY7zrgwLkWwjr14EUt8QZxfOdfzGUNTAV3bRJmDRcDItYX2azJSvcFtaMWU9HdQvooOtHu1EiUmTQCtVXea9FioIXaVUU7i44Mex6u_wpSRYGKm3ZUVa9-5kc8RwtgthmgLPyQLmyOr5CeUxfPU7rQw4xrxCfSbVCm8e7YMCMloWuu4wMCaL-307ZgFRd4sCCuayW7-MHXIJ9957mWOHm0MzLgkGInrnQ6-2aNFdFJWZennz9Gjtn1754ouub6_P0gOYDjFYzef2XiylAmbHwedVmuhQm_BGRWsPXBkserCaIUs56BIMkv5vHcVISMmtQhWzvy2mOLlHiFAC8YqjuUX8JV_4hMgmqo1LxQwhrsATPbqBZ9rGncoYYoLMwcw69Omosf6okR6oXnfhEgEP9dCSjt8V7u3Vw7TCvHOIwV1jFkdWULzrhrpu893_cHHp7Hl6Q4poP-ZIU-DU_kvUNVgwc0c0ARndCRmGF1uTaM94a9ywCLUFvNyat30Au60YC1FVyUO_FIlCHl9eCGL6NAL9KGIddHD9p1-vOBqHVr0eJ_YSIrTfjXR_y3)
  + 相比与example中地设计，将小怪(Monster)作为(Monsters)的内部类，并且在Monster的构造函数中利用static int flag来设置每个Monster的rank，其余方法不变，在放置每个Monster的时候用到了一个Location.get方法，该方法返回随机不重复的256个整数，用来将小怪随机放置。
  + 时序图
  + ![](http://www.plantuml.com/plantuml/png/LKyzJyD03DtzApmc0vKe7qCbKDbXG6MhEXo9cvvozKLdHn7_djHEYvZkVJpxdhUYeUXuJl0UcV3k5UtTOEIey95Pb8fSz1jsRw6muz3Rd8CDTgHV9p86kroKYhcEV1Qhpp4slMkrh_WN4b8K8qij_zxDOLHSFpt_5TACQKvTzznkC7KSWBCI9Zegt9kqqlnMIlZnOFXEj3ya1m9hZApx0vR0lLI9kDFJozLTEQ_XOQc7AOVMinYunIQaP5PLmoDE9IfXcoUUSntceraMb2aCE9JSa0ZGB5nAmdP6updz0W00)
  
+ task3

  + 类型设计
  + ![](http://www.plantuml.com/plantuml/png/pLNDZjCm4BxxANnCOBFY0M2rx0MGYhHG10U4a9jEWwbZHxQpFogyE-DuF6tJhSHnU_7acv_vvlDOlGvH-JZsHhH6XI2NLcrX9mQlxrG4YTwesupA-0icGmpZoY1wvEmWVY5_LPTyBvVEfoDCHqcyStej0yJih8vYE5SkezUs-_v33ie7k3NALXcI0zeSbwl10xHZ18f8nOTQYByqrSArIDNPdI3ERxrNZmiTukiFDa87_aeQ_2fkRMCQg4gdhhdCHsS3KjpBiz5McIdQFu5rJs0hncvTq8cJ7CYOoVhEZNwTM4p6pUDdPRSJ8O_6Vlg2_9ob9tnZLFVcrLprqhWwOL2NKFPq1-7rSQ5xDR0hSrNMuOfuYcCLloep0cRFPGny6mJWLVVa4ga75j2HV9XFLYf99ecIBaXeYy16jI0NAFRAu1B_py1d9frHP-OgUlsmExd3jAHaXYELXZ5Mn4UQV5xGKb5OyVAwpJrOExffNojsqPP7bur3SPSjM9mzCvNzT8YYkEm5fHhNYPjnim4FwszU9rtlfmCBiPJqUdT2ukzmBEFKEh55Rc2W1nj3VHAKtdDr15Fl9BLHza3Nct65ar8tLZStKE9CPrLp96zabl12fkCt-a_fdAF2N3wDkjq-3ohlGGtFWWal-fx7RAlviH5UxVshTAQxvXTyUVddgXGG9R1f7BSHl10Sdcr1ainXlhGPdl-RNDCmq8ATW8a077vFiUNXl4I4wH28bPasLKv8TfQO5qt3UVpkSZdwefw8yF-Ik0Qx7dlp3m00)
  + 该类型设计和排列成一列的基本没有什么区别，只是在toString()方法中，对每个小怪计数i累加，当i%16==0输出‘\n’即可显示成16一行 只有这一个为小改动。如果为了美观每一行的小怪之间也要有间隙，则对于每个小怪的toString（）函数也进行重写，设定等宽，再多几个空格即可。
  + 时序图
  + ![](http://www.plantuml.com/plantuml/png/JO-zRiCm38HtFWL7UsY0fZz3WHRftWn5kWKPL9jn1CkK8L5m-_PLA0lDTdVVYJZjefWWQNAmDnBi3zwzuQfUqB8Ls7kEGY4ggRgmrSA1pKXNhYB3WUJhGkhWu4FkA2sglCNcCzbkB5bxSwAM8Wb6DNLQ7Q1uJeBRf-V_IUBHMQPwwUOVcgSPs0kXexF0FKxADkBVGp2_kVnXsNmxEfvS4H6sQ5cE9mo6nzWuua4khvLkYc_XOHs9pfk-TD5mZvrnJb7JmYCkmGfXxnVElG7zMP4Mus9cd8FlA4QW75ndmYwhDBa_)



[B站结果录屏演示](https://www.bilibili.com/video/BV1ch411H7xn/)

